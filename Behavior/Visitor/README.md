
访问者模式（Visitor）
意图：
表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

适用性：
在下列情况下使用Visitor模式：
1、一个对象结构包含很多类对象，它们有不同的接口，而你想对这些对象实施一些依赖于某具体类的操作。
2、需要对一个对象结构中的对象进行很多不同的并且不相关的操作。而你想避免让这些操作“污染”这些对象的类。
3、定义对象结构的类很少改变，但经常需要在此结构上定义新的操作。改变对象结构类需要重定义对所有访问者的接口，这可能需要很大的代价。
如果对象结构类经常改变，那么可能还是在这些类中定义这些操作较好。

结构:
Visitor（抽象访问者）：抽象访问者为对象结构中每一个具体元素类ConcreteElement声明一个访问操作，
从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者则需要实现这些操作方法，定义对这些元素的访问操作。
ConcreteVisitor（具体访问者）：具体访问者实现了抽象访问者声明的方法，每一个操作作用于访问对象结构中一种类型的元素。
Element（抽象元素）：一般是一个抽象类或接口，定义一个Accept方法，该方法通常以一个抽象访问者作为参数。
ConcreteElement（具体元素）：具体元素实现了Accept方法，在Accept方法中调用访问者的访问方法以便完成一个元素的操作。
ObjectStructure（对象结构）：对象结构是一个元素的集合，用于存放元素对象，且提供便利其内部元素的方法。

类图：
Visitor.jpg

优点:
增加新的访问操作十分方便
将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中，类的职责更加清晰

缺点:
增加新的元素类很困难，需要在每一个访问者类中增加相应访问操作代码
元素对象有时候必须暴露一些自己的内部操作和状态，否则无法供访问者访问

总结：
Visitor 模式则提供了一种解决方案:将更新(变更)封装到一个类中(访问操作)，并由待更改类提供一个接收接口，则可达到效果。
Visitor 模式可以使得 Element 在不修改自己的同时增加新的操作，但是这也带来了至少
以下的两个显著问题:
1) 破坏了封装性。Visitor 模式要求Visitor可以从外部修改 Element 对象的状态，这一般通过两个方式来实现:
a)Element提供足够的 public 接口，使得Visitor可以通过调用这些接口达到修改Element状态的目的;
b)Element暴露更多的细节给Visitor，或者让Element提供public的实现给Visitor(当然也给了系统中其他的对象)，或者将Visitor声明为Element的friend类，仅将细节暴露给 Visitor。但是无论那种情况,特别是后者都将是破坏了封装性原则(实际上就是C++的friend机制得到了很多的 面向对象专家的诟病)。
2) ConcreteElement 的扩展很困难:每增加一个Element的子类，就要修改Visitor的接口，使得可以提供给这个新增加的子类的访问机制。从上面我们可以看到，或者增加一个用于处理新增类的 Visit()接口，或者重载一个处理新增类的 Visit()操作，或者要修改RTTI方式实现的 Visit()实现。无论那种方式都给扩展新的Element子类带来了困难。
