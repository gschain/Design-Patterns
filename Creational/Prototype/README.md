
原型模式（Prototype）
意图：
用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

适用性：
当一个系统应该独立于它的产品创建、构成和表示时，要使用Prototype模式；
以及
1、当要实例化的类是在运行时刻指定时，例如，通过动态装载。
2、当一个类的实例只能有几个不同状态组合中的一种时，建立相应数目的原型
并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。

结构：

优点
当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过
复制一个已有的实例可以提高新实例的创建效率。可以使用深复制的方式保存对
象的状态。将对象复制一份并将其状态保存起来，以便于在使用的时候使用，比
如恢复到某一个历史状态，可以辅助实现撤销操作。

缺点
需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已
有的类进行改造时，需要修改源代码，违背了开闭原则。为了支持深复制，当对
象之间存在多重嵌套引用关系时，每一层对象都必须支持深复制，实现起来可能比较麻烦。

总结
1、当你需要多个属性相同的对象的时候，而且创建新对象的成本较大，需要请求外部资源等，就可以考虑原型模式
2、你可以理解成，原型模式就是克隆几个相同的对象，或者是相似的对象只是稍作修改的情况
3、注意浅拷贝和深拷贝的区别
    浅拷贝：对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象。
    深拷贝：对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制。


Prototype 模式通过复制原型(Prototype)而获得新对象创建的功能，这里 Prototype 本 身就是“对象工厂”(因为能够生产对象)，
实际上 Prototype 模式和 Builder 模式、 AbstractFactory 模式都是通过一个类(对象实例)来专门负责对象的创建工作(工厂对象)， 
它们之间的区别是:
Builder 模式重在复杂对象的一步步创建(并不直接返回对象)，
AbstractFactory 模式重在产生多个相互依赖类的对象，
而 Prototype 模式重在从自身复制自己创建新类。
