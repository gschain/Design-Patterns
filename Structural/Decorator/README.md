
装饰模式(Decorator)
意图：
动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。

适用性：
以下情况时有Decorator模式：
1、在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
2、处理那些可以撤销的职责。
3、当不能采用生成子类的方法进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。
另一种情况可能是因为类定义被隐藏，或类定义不能用于生成子类。

结构
Component （抽象构件）：具体构件和抽象装饰类的基类，声明了在具体构建中实现的业务方法。
ConcreteComponent（具体构件）：抽象构件的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。
Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。
ConcreteDecorator（具体装饰类）：抽象装饰类的子类，负责向构件添加新的职责。

类图：
Decorator.jpg

优点:
对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加！
可以对一个对象进行多次装饰，从而创造出很多不同行为的组合，得到功能更为强大的对象！
具体构件类与具体装饰类可以独立变化，可以根据需要增加新的具体构建和具体装饰，原有代码无需修改，符合开放封闭原则！

缺点:
虽然装饰模式拱了一种比继承更加灵活机动的方案，但同时也意味着比继承更加易于出错，排错也很困难。
特别是经过多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。

总结：
我们需要为一个已经定义好的类添加新的职责(操作)，通常的情况我们会给定义一个新类继承自定义好的类,通过继承的方式解决这样的情况还带来了系统的复 
杂性，因为继承的深度会变得很深。
Decorator模式除了采用组合的方式取得了比采用继承方式更好的效果，Decorator模式还给设计带来一种“即用即付”的方式来添加职责。
在OO设计和分析经常有这样一种情况: 为了多态，通过父类指针指向其具体子类，但是这就带来另外一个问题，当具体子类要添加 新的职责，
就必须向其父类添加一个这个职责的抽象接口，否则是通过父类指针是调用不到 这个方法了。这样处于高层的父类就承载了太多的特征(方法)，
并且继承自这个父类的所有子类都不可避免继承了父类的这些接口，但是可能这并不是这个具体子类所需要的。而在Decorator模式提供了一种
较好的解决方法，当需要添加一个操作的时候就可以通过Decorator模式来解决，你可以一步步添加新的职责。
