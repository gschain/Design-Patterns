
外观模式（Facade）
意图：
为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

适用性：
以下情况时有Facade模式：
1、当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。
这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给哪些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供
一个简单的缺省视图，这一视图对绝大多数用户来说已经足够，而哪些需要更多的定制性的用户可以越过Facadeceng。
2、客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性
和可移植性。
3、当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的，你可以让它们仅通过
Facade进行通讯，从而简化了它们之间的依赖关系。

结构:
Facade（外观角色）：在客户端可以调用这个角色的方法，在外观角色中可以知道相关的子系统的功能和责任；
在正常情况下，它将所有从客户端发来的请求委派到相应的子系统中去，传递给相应的子系统对象处理。
SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，
它实现子系统的功能；子系统并不知道外观（又称为门面）的存在，对于子系统而言，外观角色仅仅是另一个客户端而已。

类图：
Facade.jpg

优点:
对客户端屏蔽了子系统组件，减少了客户端需要处理的对象数量并且使得子系统使用起来更加容易。
实现了子系统与客户端之间松耦合。
提供了一个访问子系统的统一入口，并不影响客户端直接使用子系统。

缺点:
使用合适的情况下没有什么问题

总结：
1、这个模式特别容易，这也是经常被使用的一种模式，很多时候我们都在使用，只是你可能还不知道它的名字而已。
2、通过一个外观从而让访问者可以避免直接访问过多子系统的接口，可以直接通过访问外观就能达到最终的目的。
3、如果你写过J2EE的项目，很多时候我们使用service调用多个dao达到目的，从另一个角度讲，service就是一种外观。
4、与适配器模式对比：
    适配器模式是把一个原来无法访问的接口，通过适配让客户端能进行访问。
    外观模式原来的接口可以正常的访问，只是封装了一个更简单的接口从而方便客户端的访问。
