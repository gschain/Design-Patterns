
享元模式（Flyweight）
意图：
运用共享技术有效地支持大量细粒度的对象。

适用性：
Flyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它。当以下情况都成立时使用Flyweight模式：
1、一个应用程序使用了大量的对象。
2、完全由于使用大量的对象，造成很大的存储开销。
3、对象的大多数状态都可变为外部状态。
4、如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多祖对象。
5、应用程序不依赖于对象标识。由于Flyweight对象可以共享，对于概念上明显有别的对象，标识测试将返回真值。

结构:
Flyweight（抽象享元类）：一个接口或抽象类，声明了具体享元类的公共方法。
ConcreteFlyweight（具体享元类）：实现了抽象享元类，其实例称为享元对象。
UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为费共享具体享元类。
FlyweightFactory（享元工厂类）：用于创建并管理享元对象，一般设计为一个存储“Key-Value”键值对的集合（可以结合工厂模式设计）。
其作用就在于：提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，
如果享元池中不存在，那么则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。

类图：
Flyweight.jpg

优点:
可以极大减少内存中对象的数量，使得相同或相似对象在内存中只有一份

缺点:
为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长

总结：
1、这个设计模式的主要用法是：
将一个系统中包含有相同或者相似的对象组合在一起，通过一个对象包含在内并且可以进行管理
2、只有需要多次重复使用的情况下才值得使用
3、例子中做了简化：
    其中上述说到的相似对象就是拥有同一个抽象的对象，我们简化成同一个对象
    其中的享元工厂类我们直接使用最简单的兑现管理方式，而产生可以根据实际的需要进行构建
